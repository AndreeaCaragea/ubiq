# Introduction 

Networked VR applications make use of different types of logging, such as:

1. Debug Logs
2. Experiment Logs
3. Network Traces

<p/>

1. Refers to logging expected and exceptional events that occur during a regular session. The purpose is post-hoc debugging of application code.
2. Refers to logging application-specific data, such as measurements for an experiment built in Ubiq.
3. Refers to captures of network traffic to debug low-level netcode bugs that can be reliably reproduced.

1 & 2 are handled by Ubiq's Event Logging system. (3 has very different performance implications, so is handled seperately.)


# Use Case

The Event Logging System is for collecting low or medium frequency events from multiple peers. The Event Logging system can log both system and application events, which can then be extracted from Ubiq and analysed.

Events are discrete, but otherwise have very few restrictions. It is up to the user to ensure that event logging in their application doesn't negatively affect performance.

# Overview

Events are generated by `EventLogger` instances placed throughout the application. Events generated by these components are passed to a `LogManager` instance. The `LogManager` forwards all events in an application to a `LogCollector`, and the `LogCollector` writes them to disk (or database, or other endpoint). `LogManager` and `LogCollector` can be on the same machine or separated by the network.

## EventLogger

`EventLogger` instances are lightweight objects that the application uses to log events.
Calls to an `EventLogger` are expected to be placed throughout the system persistently, rather than gated with pre-processor defines.

The most common types of event logger are the `ComponentEventLogger`, which is designed to work with `MonoBehaviour` instances, and the `ContextEventLogger`, which is designed to work with Components that have a `NetworkContext`.

`EventLogger` instances attach to a single `LogManager`. Event logger constructors find the closest `LogManager` automatically.

`EventLogger` methods can be safely called from outside the Unity main thread. They should not be called from outside CLR threads.

`EventLogger` instances are designed to have zero overhead when logs are not actually written anywhere. The `Log` method has many overloads to avoid boxing, and serialisation only runs when logging is on. Logs are only written when there is an active `LogManager` in the scene.

It is encouraged to make as many `EventLogger` instances as needed. Individual event loggers are simple, with few options. Use multiple `EventLogger` instances within a class to get fine-grained control over logging, for example different log levels.

## LogManager

When a `LogManager` is placed in a scene, it will recieve events from any nearby event loggers. By default the `LogManager` will cache a fixed number of events (50 Mb worth), dropping older events as new ones are receieved.

When instructed, the `LogManager` will forward these events and any new ones to a `LogCollector`, the Component that actually writes the logs to an endpoint such as a disk, or database.

Each Peer must have at least one `LogManager` to emit log events; event loggers cannot communicate over the network themselves. Only one `LogCollector` is needed between all Peers, though multiple collectors may be present (in which case all will receive all events).

# LogCollector

`LogCollector` instances receive events from `LogManager` instances and write them to an appropriate location. `LogCollector` instances can also control `LogManager` instances remotely - for example, starting and stopping the transmission of events.

## Local Log Collection

`LogCollector` instances will automatically recieve events sent over the network, but will also receive events from `LogManager` instances on the same peer, even without a network connection.

`LogCollector` instances will find all `LogManager` instances at the local Peer and register them on start-up. If a `LogManager` is instantiated in the Root of the scene, it will find all `LogManager` instances in the scene. If it is instantiated in a branch of the scene, it will find all `LogManager` instances within that branch.

A `LogManager` does not have to be transmitting for messages to be collected locally. 

This allows logging events entirely on one machine, for example, data collection for an experiment, without using the network.

# Analysis

A `LogCollector` outputs a stream of structured logs.

What happens next is up to the user. Logs can be forwarded to a stack like the ELK, processed with a third-party tool such as Matlab or Excel, or parsed programmatically with, e.g., Python. By default, the `LogCollector` will write them as Json files into the Persistent Data directory of whatever platform it is running on.

All files are standards compliant Json, with the top level object being an array and each event being a member of the array.

See the [Analysis](eventloganalysis.md) section for examples of how to process the logs.
